/*
 * Sistema de Torre de Fuga - M√≥dulo 3
 * 
 * Sistema avan√ßado de organiza√ß√£o de componentes para montagem de torre de fuga.
 * Implementa m√∫ltiplos algoritmos de ordena√ß√£o, busca bin√°ria otimizada e
 * an√°lise de desempenho em tempo real.
 * 
 * Algoritmos implementados:
 * - Bubble Sort (ordena√ß√£o por nome)
 * - Insertion Sort (ordena√ß√£o por tipo)
 * - Selection Sort (ordena√ß√£o por prioridade)
 * - Busca Bin√°ria (busca por nome em array ordenado)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Defini√ß√£o da estrutura Componente
typedef struct {
    char nome[30];      // Nome do componente (ex: "chip central")
    char tipo[20];      // Tipo (ex: "controle", "suporte", "propuls√£o")
    int prioridade;     // Prioridade de 1 a 10
} Componente;

// Constantes do sistema
#define MAX_COMPONENTES 20
#define TAMANHO_NOME 30
#define TAMANHO_TIPO 20

// Vari√°veis globais
Componente torre[MAX_COMPONENTES];
int totalComponentes = 0;
int ordenadoPorNome = 0;    // Flag para indicar se est√° ordenado por nome
int ordenadoPorTipo = 0;    // Flag para indicar se est√° ordenado por tipo
int ordenadoPorPrioridade = 0; // Flag para indicar se est√° ordenado por prioridade

// Contadores de compara√ß√µes
int comparacoesBubble = 0;
int comparacoesInsertion = 0;
int comparacoesSelection = 0;
int comparacoesBusca = 0;

// Declara√ß√£o das fun√ß√µes principais
void exibirMenuPrincipal();
void cadastrarComponente();
void mostrarComponentes();
void limparBuffer();
void resetarContadores();
void exibirEstatisticas();

// Fun√ß√µes de ordena√ß√£o
void bubbleSortNome(Componente arr[], int n);
void insertionSortTipo(Componente arr[], int n);
void selectionSortPrioridade(Componente arr[], int n);

// Fun√ß√£o de busca
int buscaBinariaPorNome(Componente arr[], int n, char nome[]);

// Fun√ß√µes de medi√ß√£o e an√°lise
double medirTempo(void (*algoritmo)(Componente[], int), Componente arr[], int n);
void compararAlgoritmos();
void iniciarMontagem();
void testarBuscas();

/*
 * Fun√ß√£o principal do programa
 */
int main() {
    int opcao;
    
    printf("=== SISTEMA DE TORRE DE FUGA - M√ìDULO 3 ===\n");
    printf("Sistema Avan√ßado de Organiza√ß√£o de Componentes\n\n");
    
    do {
        exibirMenuPrincipal();
        printf("Escolha uma op√ß√£o: ");
        scanf("%d", &opcao);
        limparBuffer();
        
        printf("\n");
        
        switch(opcao) {
            case 1:
                cadastrarComponente();
                break;
            case 2:
                if (totalComponentes == 0) {
                    printf("‚ùå Nenhum componente cadastrado!\n");
                } else {
                    printf("üîÑ Ordenando por nome (Bubble Sort)...\n");
                    resetarContadores();
                    double tempo = medirTempo(bubbleSortNome, torre, totalComponentes);
                    ordenadoPorNome = 1;
                    ordenadoPorTipo = 0;
                    ordenadoPorPrioridade = 0;
                    printf("‚úÖ Ordena√ß√£o conclu√≠da!\n");
                    printf("Compara√ß√µes: %d | Tempo: %.6f segundos\n", comparacoesBubble, tempo);
                    mostrarComponentes();
                }
                break;
            case 3:
                if (totalComponentes == 0) {
                    printf("‚ùå Nenhum componente cadastrado!\n");
                } else {
                    printf("üîÑ Ordenando por tipo (Insertion Sort)...\n");
                    resetarContadores();
                    double tempo = medirTempo(insertionSortTipo, torre, totalComponentes);
                    ordenadoPorNome = 0;
                    ordenadoPorTipo = 1;
                    ordenadoPorPrioridade = 0;
                    printf("‚úÖ Ordena√ß√£o conclu√≠da!\n");
                    printf("Compara√ß√µes: %d | Tempo: %.6f segundos\n", comparacoesInsertion, tempo);
                    mostrarComponentes();
                }
                break;
            case 4:
                if (totalComponentes == 0) {
                    printf("‚ùå Nenhum componente cadastrado!\n");
                } else {
                    printf("üîÑ Ordenando por prioridade (Selection Sort)...\n");
                    resetarContadores();
                    double tempo = medirTempo(selectionSortPrioridade, torre, totalComponentes);
                    ordenadoPorNome = 0;
                    ordenadoPorTipo = 0;
                    ordenadoPorPrioridade = 1;
                    printf("‚úÖ Ordena√ß√£o conclu√≠da!\n");
                    printf("Compara√ß√µes: %d | Tempo: %.6f segundos\n", comparacoesSelection, tempo);
                    mostrarComponentes();
                }
                break;
            case 5: {
                if (!ordenadoPorNome) {
                    printf("‚ö†Ô∏è  ATEN√á√ÉO: Para busca bin√°ria, os componentes devem estar ordenados por nome!\n");
                    printf("Use a op√ß√£o 2 para ordenar por nome primeiro.\n");
                    break;
                }
                
                char nomeBusca[TAMANHO_NOME];
                printf("=== BUSCA DO COMPONENTE-CHAVE ===\n");
                printf("Digite o nome do componente-chave: ");
                fgets(nomeBusca, TAMANHO_NOME, stdin);
                nomeBusca[strcspn(nomeBusca, "\n")] = 0;
                
                resetarContadores();
                clock_t inicio = clock();
                int indice = buscaBinariaPorNome(torre, totalComponentes, nomeBusca);
                clock_t fim = clock();
                double tempo = ((double)(fim - inicio)) / CLOCKS_PER_SEC;
                
                if (indice != -1) {
                    printf("üéØ COMPONENTE-CHAVE ENCONTRADO!\n");
                    printf("Nome: %s\n", torre[indice].nome);
                    printf("Tipo: %s\n", torre[indice].tipo);
                    printf("Prioridade: %d\n", torre[indice].prioridade);
                    printf("Posi√ß√£o: %d\n", indice + 1);
                } else {
                    printf("‚ùå Componente-chave n√£o encontrado!\n");
                }
                printf("Compara√ß√µes: %d | Tempo: %.6f segundos\n", comparacoesBusca, tempo);
                break;
            }
            case 6:
                mostrarComponentes();
                break;
            case 7:
                compararAlgoritmos();
                break;
            case 8:
                exibirEstatisticas();
                break;
            case 9:
                iniciarMontagem();
                break;
            case 10:
                testarBuscas();
                break;
            case 11:
                printf("Saindo do sistema... Boa sorte na fuga!\n");
                break;
            default:
                printf("Op√ß√£o inv√°lida! Tente novamente.\n");
        }
        
        printf("\n");
        
    } while(opcao != 11);
    
    return 0;
}

/*
 * Exibe o menu principal do sistema
 */
void exibirMenuPrincipal() {
    printf("=== MENU PRINCIPAL ===\n");
    printf("1. Cadastrar componente\n");
    printf("2. Ordenar por nome (Bubble Sort)\n");
    printf("3. Ordenar por tipo (Insertion Sort)\n");
    printf("4. Ordenar por prioridade (Selection Sort)\n");
    printf("5. Buscar componente-chave (Busca Bin√°ria)\n");
    printf("6. Exibir componentes\n");
    printf("7. Comparar algoritmos\n");
    printf("8. Exibir estat√≠sticas\n");
    printf("9. Iniciar montagem da torre\n");
    printf("10. Testar buscas (Sequencial vs Bin√°ria)\n");
    printf("11. Sair\n");
    printf("======================\n");
    printf("Status: %d/%d componentes | Ordenado: %s\n", 
           totalComponentes, MAX_COMPONENTES,
           ordenadoPorNome ? "Nome" : (ordenadoPorTipo ? "Tipo" : (ordenadoPorPrioridade ? "Prioridade" : "N√£o")));
}

/*
 * Limpa o buffer de entrada
 */
void limparBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

/*
 * Reseta todos os contadores de compara√ß√µes
 */
void resetarContadores() {
    comparacoesBubble = 0;
    comparacoesInsertion = 0;
    comparacoesSelection = 0;
    comparacoesBusca = 0;
}


/*
 * Cadastra um novo componente no sistema
 */
void cadastrarComponente() {
    if (totalComponentes >= MAX_COMPONENTES) {
        printf("‚ùå ERRO: Limite m√°ximo de componentes atingido (%d)!\n", MAX_COMPONENTES);
        return;
    }
    
    Componente novoComponente;
    
    printf("=== CADASTRAR COMPONENTE ===\n");
    
    // Solicita o nome do componente
    printf("Digite o nome do componente: ");
    fgets(novoComponente.nome, TAMANHO_NOME, stdin);
    novoComponente.nome[strcspn(novoComponente.nome, "\n")] = 0;
    
    // Verifica se o componente j√° existe
    for (int i = 0; i < totalComponentes; i++) {
        if (strcmp(torre[i].nome, novoComponente.nome) == 0) {
            printf("‚ö†Ô∏è  Componente '%s' j√° existe!\n", novoComponente.nome);
            return;
        }
    }
    
    // Solicita o tipo do componente
    printf("Digite o tipo do componente (controle/suporte/propuls√£o/outros): ");
    fgets(novoComponente.tipo, TAMANHO_TIPO, stdin);
    novoComponente.tipo[strcspn(novoComponente.tipo, "\n")] = 0;
    
    // Solicita a prioridade
    do {
        printf("Digite a prioridade (1-10): ");
        scanf("%d", &novoComponente.prioridade);
        limparBuffer();
        
        if (novoComponente.prioridade < 1 || novoComponente.prioridade > 10) {
            printf("‚ùå ERRO: Prioridade deve estar entre 1 e 10!\n");
        }
    } while (novoComponente.prioridade < 1 || novoComponente.prioridade > 10);
    
    // Adiciona o componente ao array
    torre[totalComponentes] = novoComponente;
    totalComponentes++;
    
    // Marca como n√£o ordenado
    ordenadoPorNome = 0;
    ordenadoPorTipo = 0;
    ordenadoPorPrioridade = 0;
    
    printf("‚úÖ Componente '%s' cadastrado com sucesso!\n", novoComponente.nome);
    mostrarComponentes();
}

/*
 * Exibe todos os componentes cadastrados
 */
void mostrarComponentes() {
    printf("=== COMPONENTES DA TORRE ===\n");
    
    if (totalComponentes == 0) {
        printf("üì¶ Nenhum componente cadastrado!\n");
        printf("Use a op√ß√£o 1 para cadastrar componentes.\n");
        return;
    }
    
    printf("Total: %d/%d componentes\n", totalComponentes, MAX_COMPONENTES);
    printf("Ordena√ß√£o atual: %s\n\n", 
           ordenadoPorNome ? "Por Nome (Bubble Sort)" : 
           (ordenadoPorTipo ? "Por Tipo (Insertion Sort)" : 
           (ordenadoPorPrioridade ? "Por Prioridade (Selection Sort)" : "Sem ordena√ß√£o")));
    
    // Cabe√ßalho da tabela
    printf("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n");
    printf("‚îÇ Pos ‚îÇ Nome                         ‚îÇ Tipo               ‚îÇ Prioridade ‚îÇ\n");
    printf("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n");
    
    // Lista todos os componentes
    for (int i = 0; i < totalComponentes; i++) {
        printf("‚îÇ %-3d ‚îÇ %-28s ‚îÇ %-18s ‚îÇ %-10d ‚îÇ\n", 
               i + 1, 
               torre[i].nome, 
               torre[i].tipo, 
               torre[i].prioridade);
    }
    
    printf("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    
    // Estat√≠sticas por tipo
    printf("\n=== ESTAT√çSTICAS POR TIPO ===\n");
    int contadores[4] = {0}; // controle, suporte, propuls√£o, outros
    
    for (int i = 0; i < totalComponentes; i++) {
        if (strstr(torre[i].tipo, "controle") != NULL) {
            contadores[0]++;
        } else if (strstr(torre[i].tipo, "suporte") != NULL) {
            contadores[1]++;
        } else if (strstr(torre[i].tipo, "propuls√£o") != NULL || 
                   strstr(torre[i].tipo, "propulsao") != NULL) {
            contadores[2]++;
        } else {
            contadores[3]++;
        }
    }
    
    printf("üéõÔ∏è  Controle: %d componentes\n", contadores[0]);
    printf("üîß Suporte: %d componentes\n", contadores[1]);
    printf("üöÄ Propuls√£o: %d componentes\n", contadores[2]);
    printf("‚öôÔ∏è  Outros: %d componentes\n", contadores[3]);
}

/*
 * Exibe estat√≠sticas de desempenho
 */
void exibirEstatisticas() {
    printf("=== ESTAT√çSTICAS DE DESEMPENHO ===\n");
    printf("Total de componentes: %d/%d\n", totalComponentes, MAX_COMPONENTES);
    printf("\nüìä COMPARA√á√ïES POR ALGORITMO:\n");
    printf("‚îú‚îÄ Bubble Sort (Nome): %d compara√ß√µes\n", comparacoesBubble);
    printf("‚îú‚îÄ Insertion Sort (Tipo): %d compara√ß√µes\n", comparacoesInsertion);
    printf("‚îú‚îÄ Selection Sort (Prioridade): %d compara√ß√µes\n", comparacoesSelection);
    printf("‚îî‚îÄ Busca Bin√°ria: %d compara√ß√µes\n", comparacoesBusca);
    
    printf("\nüéØ STATUS DE ORDENA√á√ÉO:\n");
    printf("‚îú‚îÄ Ordenado por Nome: %s\n", ordenadoPorNome ? "‚úÖ Sim" : "‚ùå N√£o");
    printf("‚îú‚îÄ Ordenado por Tipo: %s\n", ordenadoPorTipo ? "‚úÖ Sim" : "‚ùå N√£o");
    printf("‚îî‚îÄ Ordenado por Prioridade: %s\n", ordenadoPorPrioridade ? "‚úÖ Sim" : "‚ùå N√£o");
    
    printf("\n‚ö° COMPLEXIDADE DOS ALGORITMOS:\n");
    printf("‚îú‚îÄ Bubble Sort: O(n¬≤) - Quadr√°tica\n");
    printf("‚îú‚îÄ Insertion Sort: O(n¬≤) pior caso, O(n) melhor caso\n");
    printf("‚îú‚îÄ Selection Sort: O(n¬≤) - Quadr√°tica\n");
    printf("‚îî‚îÄ Busca Bin√°ria: O(log n) - Logar√≠tmica\n");
    
    printf("==================================\n");
}


/*
 * ========================================
 * ALGORITMOS DE ORDENA√á√ÉO
 * ========================================
 */

/*
 * Bubble Sort - Ordena√ß√£o por nome (alfab√©tica)
 * Complexidade: O(n¬≤)
 * Compara elementos adjacentes e os troca se estiverem fora de ordem
 */
void bubbleSortNome(Componente arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int trocou = 0; // Flag para otimiza√ß√£o
        
        for (int j = 0; j < n - i - 1; j++) {
            comparacoesBubble++; // Conta cada compara√ß√£o
            
            if (strcmp(arr[j].nome, arr[j + 1].nome) > 0) {
                // Troca os elementos
                Componente temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                trocou = 1;
            }
        }
        
        // Se n√£o houve trocas, o array j√° est√° ordenado
        if (!trocou) {
            break;
        }
    }
}

/*
 * Insertion Sort - Ordena√ß√£o por tipo (alfab√©tica)
 * Complexidade: O(n¬≤) no pior caso, O(n) no melhor caso
 * Insere cada elemento na posi√ß√£o correta em rela√ß√£o aos elementos j√° ordenados
 */
void insertionSortTipo(Componente arr[], int n) {
    for (int i = 1; i < n; i++) {
        Componente chave = arr[i];
        int j = i - 1;
        
        // Move elementos maiores que a chave uma posi√ß√£o √† frente
        while (j >= 0) {
            comparacoesInsertion++; // Conta cada compara√ß√£o
            
            if (strcmp(arr[j].tipo, chave.tipo) > 0) {
                arr[j + 1] = arr[j];
                j--;
            } else {
                break;
            }
        }
        
        arr[j + 1] = chave;
    }
}

/*
 * Selection Sort - Ordena√ß√£o por prioridade (num√©rica)
 * Complexidade: O(n¬≤)
 * Encontra o menor elemento e o coloca na posi√ß√£o correta
 */
void selectionSortPrioridade(Componente arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int indiceMenor = i;
        
        // Encontra o elemento com menor prioridade
        for (int j = i + 1; j < n; j++) {
            comparacoesSelection++; // Conta cada compara√ß√£o
            
            if (arr[j].prioridade < arr[indiceMenor].prioridade) {
                indiceMenor = j;
            }
        }
        
        // Troca o elemento atual com o menor encontrado
        if (indiceMenor != i) {
            Componente temp = arr[i];
            arr[i] = arr[indiceMenor];
            arr[indiceMenor] = temp;
        }
    }
}

/*
 * Fun√ß√£o para medir tempo de execu√ß√£o de algoritmos de ordena√ß√£o
 */
double medirTempo(void (*algoritmo)(Componente[], int), Componente arr[], int n) {
    // Cria uma c√≥pia do array para n√£o afetar o original durante a medi√ß√£o
    Componente copia[MAX_COMPONENTES];
    for (int i = 0; i < n; i++) {
        copia[i] = arr[i];
    }
    
    clock_t inicio = clock();
    algoritmo(copia, n); // Executa o algoritmo na c√≥pia
    clock_t fim = clock();
    
    // Copia o resultado de volta para o array original
    for (int i = 0; i < n; i++) {
        arr[i] = copia[i];
    }
    
    return ((double)(fim - inicio)) / CLOCKS_PER_SEC;
}

/*
 * Fun√ß√£o para comparar todos os algoritmos de ordena√ß√£o
 */
void compararAlgoritmos() {
    if (totalComponentes < 2) {
        printf("‚ùå √â necess√°rio ter pelo menos 2 componentes para comparar algoritmos!\n");
        return;
    }
    
    printf("=== COMPARA√á√ÉO DE ALGORITMOS DE ORDENA√á√ÉO ===\n");
    printf("Testando com %d componentes...\n\n", totalComponentes);
    
    // Salva o estado original
    Componente original[MAX_COMPONENTES];
    for (int i = 0; i < totalComponentes; i++) {
        original[i] = torre[i];
    }
    
    // Testa Bubble Sort
    printf("üîµ BUBBLE SORT (por nome):\n");
    resetarContadores();
    double tempoBubble = medirTempo(bubbleSortNome, torre, totalComponentes);
    printf("‚îú‚îÄ Compara√ß√µes: %d\n", comparacoesBubble);
    printf("‚îî‚îÄ Tempo: %.6f segundos\n\n", tempoBubble);
    
    // Restaura estado original
    for (int i = 0; i < totalComponentes; i++) {
        torre[i] = original[i];
    }
    
    // Testa Insertion Sort
    printf("üü¢ INSERTION SORT (por tipo):\n");
    resetarContadores();
    double tempoInsertion = medirTempo(insertionSortTipo, torre, totalComponentes);
    printf("‚îú‚îÄ Compara√ß√µes: %d\n", comparacoesInsertion);
    printf("‚îî‚îÄ Tempo: %.6f segundos\n\n", tempoInsertion);
    
    // Restaura estado original
    for (int i = 0; i < totalComponentes; i++) {
        torre[i] = original[i];
    }
    
    // Testa Selection Sort
    printf("üü° SELECTION SORT (por prioridade):\n");
    resetarContadores();
    double tempoSelection = medirTempo(selectionSortPrioridade, torre, totalComponentes);
    printf("‚îú‚îÄ Compara√ß√µes: %d\n", comparacoesSelection);
    printf("‚îî‚îÄ Tempo: %.6f segundos\n\n", tempoSelection);
    
    // Restaura estado original
    for (int i = 0; i < totalComponentes; i++) {
        torre[i] = original[i];
    }
    
    // An√°lise comparativa
    printf("üìä AN√ÅLISE COMPARATIVA:\n");
    
    // Algoritmo mais r√°pido
    if (tempoBubble <= tempoInsertion && tempoBubble <= tempoSelection) {
        printf("üèÜ Algoritmo mais r√°pido: Bubble Sort\n");
    } else if (tempoInsertion <= tempoBubble && tempoInsertion <= tempoSelection) {
        printf("üèÜ Algoritmo mais r√°pido: Insertion Sort\n");
    } else {
        printf("üèÜ Algoritmo mais r√°pido: Selection Sort\n");
    }
    
    // Algoritmo com menos compara√ß√µes
    if (comparacoesBubble <= comparacoesInsertion && comparacoesBubble <= comparacoesSelection) {
        printf("üéØ Menos compara√ß√µes: Bubble Sort (%d)\n", comparacoesBubble);
    } else if (comparacoesInsertion <= comparacoesBubble && comparacoesInsertion <= comparacoesSelection) {
        printf("üéØ Menos compara√ß√µes: Insertion Sort (%d)\n", comparacoesInsertion);
    } else {
        printf("üéØ Menos compara√ß√µes: Selection Sort (%d)\n", comparacoesSelection);
    }
    
    printf("\nüí° RECOMENDA√á√ïES:\n");
    printf("‚îú‚îÄ Para dados quase ordenados: Insertion Sort\n");
    printf("‚îú‚îÄ Para dados pequenos: Qualquer algoritmo\n");
    printf("‚îú‚îÄ Para dados grandes: Considere algoritmos O(n log n)\n");
    printf("‚îî‚îÄ Para busca frequente: Ordene primeiro, depois use busca bin√°ria\n");
    
    printf("=============================================\n");
    
    // Reseta flags de ordena√ß√£o
    ordenadoPorNome = 0;
    ordenadoPorTipo = 0;
    ordenadoPorPrioridade = 0;
}


/*
 * ========================================
 * BUSCA BIN√ÅRIA E SISTEMA DE MONTAGEM
 * ========================================
 */

/*
 * Busca Bin√°ria - Busca por nome em array ordenado
 * Complexidade: O(log n)
 * Requer que o array esteja ordenado por nome
 */
int buscaBinariaPorNome(Componente arr[], int n, char nome[]) {
    int esquerda = 0;
    int direita = n - 1;
    
    while (esquerda <= direita) {
        int meio = esquerda + (direita - esquerda) / 2;
        comparacoesBusca++; // Conta cada compara√ß√£o
        
        int comparacao = strcmp(arr[meio].nome, nome);
        
        if (comparacao == 0) {
            return meio; // Componente encontrado
        } else if (comparacao < 0) {
            esquerda = meio + 1; // Busca na metade direita
        } else {
            direita = meio - 1; // Busca na metade esquerda
        }
    }
    
    return -1; // Componente n√£o encontrado
}

/*
 * Sistema de montagem da torre de fuga
 */
void iniciarMontagem() {
    printf("=== SISTEMA DE MONTAGEM DA TORRE ===\n");
    
    if (totalComponentes == 0) {
        printf("‚ùå Nenhum componente cadastrado para montagem!\n");
        return;
    }
    
    printf("üèóÔ∏è  Iniciando processo de montagem da torre de fuga...\n\n");
    
    // Verifica se h√° componentes de todos os tipos necess√°rios
    int temControle = 0, temSuporte = 0, temPropulsao = 0;
    
    for (int i = 0; i < totalComponentes; i++) {
        if (strstr(torre[i].tipo, "controle") != NULL) temControle = 1;
        if (strstr(torre[i].tipo, "suporte") != NULL) temSuporte = 1;
        if (strstr(torre[i].tipo, "propuls√£o") != NULL || 
            strstr(torre[i].tipo, "propulsao") != NULL) temPropulsao = 1;
    }
    
    printf("üìã VERIFICA√á√ÉO DE COMPONENTES ESSENCIAIS:\n");
    printf("‚îú‚îÄ Sistema de Controle: %s\n", temControle ? "‚úÖ Dispon√≠vel" : "‚ùå Ausente");
    printf("‚îú‚îÄ Sistema de Suporte: %s\n", temSuporte ? "‚úÖ Dispon√≠vel" : "‚ùå Ausente");
    printf("‚îî‚îÄ Sistema de Propuls√£o: %s\n", temPropulsao ? "‚úÖ Dispon√≠vel" : "‚ùå Ausente");
    
    if (!temControle || !temSuporte || !temPropulsao) {
        printf("\n‚ö†Ô∏è  ATEN√á√ÉO: Componentes essenciais est√£o faltando!\n");
        printf("A torre pode n√£o funcionar corretamente.\n");
    }
    
    // Busca por componente-chave
    printf("\nüîç BUSCA DO COMPONENTE-CHAVE:\n");
    
    if (!ordenadoPorNome) {
        printf("‚ö†Ô∏è  Para localizar o componente-chave, √© necess√°rio ordenar por nome primeiro.\n");
        printf("Deseja ordenar agora? (s/n): ");
        
        char resposta;
        scanf(" %c", &resposta);
        limparBuffer();
        
        if (resposta == 's' || resposta == 'S') {
            printf("üîÑ Ordenando componentes por nome...\n");
            resetarContadores();
            double tempo = medirTempo(bubbleSortNome, torre, totalComponentes);
            ordenadoPorNome = 1;
            ordenadoPorTipo = 0;
            ordenadoPorPrioridade = 0;
            printf("‚úÖ Ordena√ß√£o conclu√≠da em %.6f segundos\n", tempo);
        } else {
            printf("‚ùå Montagem cancelada. Ordene os componentes e tente novamente.\n");
            return;
        }
    }
    
    char componenteChave[TAMANHO_NOME];
    printf("Digite o nome do componente-chave para ativar a torre: ");
    fgets(componenteChave, TAMANHO_NOME, stdin);
    componenteChave[strcspn(componenteChave, "\n")] = 0;
    
    resetarContadores();
    clock_t inicio = clock();
    int indiceChave = buscaBinariaPorNome(torre, totalComponentes, componenteChave);
    clock_t fim = clock();
    double tempoBusca = ((double)(fim - inicio)) / CLOCKS_PER_SEC;
    
    if (indiceChave == -1) {
        printf("‚ùå FALHA NA MONTAGEM!\n");
        printf("Componente-chave '%s' n√£o encontrado.\n", componenteChave);
        printf("Compara√ß√µes realizadas: %d | Tempo: %.6f segundos\n", comparacoesBusca, tempoBusca);
        return;
    }
    
    printf("üéØ COMPONENTE-CHAVE LOCALIZADO!\n");
    printf("Nome: %s\n", torre[indiceChave].nome);
    printf("Tipo: %s\n", torre[indiceChave].tipo);
    printf("Prioridade: %d\n", torre[indiceChave].prioridade);
    printf("Localizado em %.6f segundos com %d compara√ß√µes\n", tempoBusca, comparacoesBusca);
    
    // Simula√ß√£o da montagem
    printf("\nüèóÔ∏è  INICIANDO MONTAGEM...\n");
    printf("‚îå‚îÄ Fase 1: Instalando base de suporte...\n");
    printf("‚îú‚îÄ Fase 2: Conectando sistemas de controle...\n");
    printf("‚îú‚îÄ Fase 3: Ativando propuls√£o...\n");
    printf("‚îú‚îÄ Fase 4: Inserindo componente-chave...\n");
    printf("‚îî‚îÄ Fase 5: Teste final dos sistemas...\n");
    
    printf("\nüöÄ TORRE DE FUGA MONTADA COM SUCESSO!\n");
    printf("üéâ Parab√©ns! Voc√™ conseguiu escapar da ilha!\n");
    
    // Relat√≥rio final
    printf("\nüìä RELAT√ìRIO FINAL DA MISS√ÉO:\n");
    printf("‚îú‚îÄ Componentes utilizados: %d\n", totalComponentes);
    printf("‚îú‚îÄ Algoritmo de ordena√ß√£o: Bubble Sort\n");
    printf("‚îú‚îÄ Compara√ß√µes na busca: %d\n", comparacoesBusca);
    printf("‚îú‚îÄ Tempo de busca: %.6f segundos\n", tempoBusca);
    printf("‚îî‚îÄ Status da miss√£o: ‚úÖ SUCESSO\n");
    
    printf("=======================================\n");
}

/*
 * Fun√ß√£o para testar desempenho da busca bin√°ria vs sequencial
 */
void testarBuscas() {
    if (totalComponentes == 0) {
        printf("‚ùå Nenhum componente cadastrado para teste!\n");
        return;
    }
    
    printf("=== TESTE DE DESEMPENHO: BUSCA SEQUENCIAL vs BIN√ÅRIA ===\n");
    
    // Garante que est√° ordenado por nome para busca bin√°ria
    if (!ordenadoPorNome) {
        printf("üîÑ Ordenando por nome para habilitar busca bin√°ria...\n");
        bubbleSortNome(torre, totalComponentes);
        ordenadoPorNome = 1;
    }
    
    // Escolhe um componente aleat√≥rio para buscar
    int indiceAleatorio = rand() % totalComponentes;
    char nomeBusca[TAMANHO_NOME];
    strcpy(nomeBusca, torre[indiceAleatorio].nome);
    
    printf("Testando busca pelo componente: '%s'\n\n", nomeBusca);
    
    // Teste de busca sequencial
    printf("üîç BUSCA SEQUENCIAL:\n");
    int comparacoesSeq = 0;
    clock_t inicioSeq = clock();
    
    int encontradoSeq = -1;
    for (int i = 0; i < totalComponentes; i++) {
        comparacoesSeq++;
        if (strcmp(torre[i].nome, nomeBusca) == 0) {
            encontradoSeq = i;
            break;
        }
    }
    
    clock_t fimSeq = clock();
    double tempoSeq = ((double)(fimSeq - inicioSeq)) / CLOCKS_PER_SEC;
    
    printf("‚îú‚îÄ Resultado: %s\n", encontradoSeq != -1 ? "Encontrado" : "N√£o encontrado");
    printf("‚îú‚îÄ Compara√ß√µes: %d\n", comparacoesSeq);
    printf("‚îî‚îÄ Tempo: %.6f segundos\n\n", tempoSeq);
    
    // Teste de busca bin√°ria
    printf("üéØ BUSCA BIN√ÅRIA:\n");
    resetarContadores();
    clock_t inicioBin = clock();
    int encontradoBin = buscaBinariaPorNome(torre, totalComponentes, nomeBusca);
    clock_t fimBin = clock();
    double tempoBin = ((double)(fimBin - inicioBin)) / CLOCKS_PER_SEC;
    
    printf("‚îú‚îÄ Resultado: %s\n", encontradoBin != -1 ? "Encontrado" : "N√£o encontrado");
    printf("‚îú‚îÄ Compara√ß√µes: %d\n", comparacoesBusca);
    printf("‚îî‚îÄ Tempo: %.6f segundos\n\n", tempoBin);
    
    // Compara√ß√£o
    printf("üìä COMPARA√á√ÉO:\n");
    printf("‚îú‚îÄ Redu√ß√£o de compara√ß√µes: %.1f%%\n", 
           (1.0 - (double)comparacoesBusca / comparacoesSeq) * 100);
    printf("‚îú‚îÄ Speedup: %.1fx mais r√°pida\n", 
           tempoSeq > 0 ? tempoSeq / tempoBin : 1.0);
    printf("‚îî‚îÄ Vencedor: %s\n", 
           comparacoesBusca < comparacoesSeq ? "Busca Bin√°ria" : "Busca Sequencial");
    
    printf("=============================================\n");
}